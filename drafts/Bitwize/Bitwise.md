# Битовая арифметика

Эта тема достаточно специфическая. Работа со значениями на уровне бит считается низкоуровневой. Многие никогда не сталкиваются с этими операциями, поскольку работают через библиотеки, которые скрывают настолько тонкие подробности за объектно-ориентированным интерфейсом. Поэтому хочется пробежать по теме и больше не возвращаться. 

## Представление целочисленных значений в памяти

Для понимания как работают битовые операции следует разобраться с тем как представляются в памяти целочисленные значения. Надо отличать запись числа в виде литерала в программе и способ его представления в памяти - операции проводятся над битовым представлением, которое однозначно соответствует значению, которое может быть представлено в программе несколькими способами. Результат операции не зависит от способа задания операндов, только от их значений и типов.

### Двоичная запись

В двоичной системе счисления в записи числа используются только `0` и `1`. 

Запись через двоичный литерал.
```java
assert 0b0001 == 1
assert 0b0010 == 2
assert 0b0100 == 4
assert 0b1000 == 8
```

### Преобразования значений
#### Сужающие преобразования
#### Расширяющие преобразования
## Операции 

Для целочисленных значений определены битовые операции:

| Оператор | Английское           | Русское                  |
| -------- | -------------------- | ------------------------ |
| &        | and                  | И                        |
| \|       | or                   | ИЛИ                      |
| ^        | xor                  | исключающее ИЛИ          |
| ~        | not                  | инверсия                 |
| <<       | shift left           | сдвиг влево              |
| >>       | shift right          | сдвиг вправо             |
| >>>      | unsigned shift right | беззнаковый сдвиг вправо |

Операции определены только над значениями типа int и long. Если операнд типа byte, short или char, он будет расширен до размера результата. Тип результата будет long, если хоть один из операндов типа long, кроме вторых операндов для сдвигов. В остальных случаях это будет int.

### Унарный not

### Бинарные and, or и xor

### Сдвиги
### Дополнительные операции в классах Integer и Long
Кроме этого есть несколько полезных битовых функций в классах Integer и Long:
* highestOneBit, lowestOneBit, numberOfLeadingZeros, numberOfTrailingZeros - поиск самого старшего или младшего бита значения
* bitCount - количество бит в значении
* rotateLeft, rotateRight - сдвиг бит по кругу
* reverse - обратный порядок бит
* compress, expand - операции перемещения бит пачками
* signum - знак значения
* reverseBytes - обратный порядок байт
Эти методы не обязательно заучивать, но хорошо бы знать, что они уже реализованы, причём оптимальным для данной машины методом. Ну и просто хорошо бы посмотреть внутрь, чтобы понимать как можно жонглировать битами. Местами авторы очень красиво избавляются от if-ов получая нужное значение простой логикой.

## Применение

### Битовые маски

Набор значений `Set<Enum>`. Класс `EnumSet`.
##  Упражнения

Идея для упражнения! Написать класс для эмуляции арифметических операций с int через логические. Можно использовать только вышеперечисленное и сравнение на равенство. Сравнение на больше-меньше тоже писать через битовые операции. 
